#include <stdio.h>#include <stdlib.h>#include <string.h>#include <unistd.h>#include <sys/types.h>#include <sys/wait.h>#include <fcntl.h>#include <termios.h>#include <signal.h>#include <stdbool.h>#define MAX_COMMAND_LENGTH 100#define MAX_ARGUMENTS 10#define MAX_FILES 20 // Increase to handle multiple files#define MAX_PIPES 6#define MAX_ARGS 64#define MAX_COMMANDS 7int conditional_command = 0;// Structure to store background process informationtypedef struct {    pid_t pid;    char command[MAX_COMMAND_LENGTH];} BackgroundProcess;BackgroundProcess background_processes[MAX_PIPES];int num_background_processes = 0;pid_t shell_pgid; // Process group ID of the shellvoid execute_command(char **args, int background);void bring_to_foreground();void concatenate_files(char **files);void handle_signal(int signum); // Signal handler functionvoid execute_command(char **args, int background) {    pid_t pid, status;    pid = fork();    if (pid < 0) { //If fork fails        perror("Fork failed"); //Print error message        exit(EXIT_FAILURE);    } else if (pid == 0) { //If pid = 0 , child process executes this        // Redirection file descriptors        int fd_in = -1;  // File Descriptors for Input redirection        int fd_out = -1; // File Descriptors for Output redirection        int fd_append = -1; // File Descriptors for Append output redirection        // Look for redirection symbols and set file descriptors accordingly        for (int i = 0; args[i] != NULL; i++) {             if (strcmp(args[i], "<") == 0) { //Iterate into args argument                // Checks for symbol (Input)                fd_in = open(args[i + 1], O_RDONLY); //Open for Read only                if (fd_in < 0) { //If inputn red. returns less than 0                    perror("Input redirection failed"); //Print error if Read fails                    exit(EXIT_FAILURE);                }                dup2(fd_in, STDIN_FILENO); // Redirect stdin                close(fd_in); // Close the file descriptor                args[i] = NULL; // Remove the redirection symbol and file name from arguments                args[i + 1] = NULL;            } else if (strcmp(args[i], ">") == 0) { //Again iterate into args                // Check for redirection symbol (Output)                fd_out = open(args[i + 1], O_WRONLY | O_CREAT | O_TRUNC, 0644);                if (fd_out < 0) {                    perror("Output redirection failed");                    exit(EXIT_FAILURE);                }                dup2(fd_out, STDOUT_FILENO); // Redirect stdout                close(fd_out); // Close the file descriptor                args[i] = NULL; // Remove the redirection symbol and file name from arguments                args[i + 1] = NULL;            } else if (strcmp(args[i], ">>") == 0) { //Iterate into args                // Check for symbol(Append output redirection)                fd_append = open(args[i + 1], O_WRONLY | O_CREAT | O_APPEND, 0644);                if (fd_append < 0) {                    perror("Append output redirection failed");                    exit(EXIT_FAILURE);                }                dup2(fd_append, STDOUT_FILENO); // Redirect stdout                close(fd_append); // Close the file descriptor                args[i] = NULL; // Remove the redirection symbol and file name from arguments                args[i + 1] = NULL;            }        }        if (strcmp(args[0], "newt") == 0) { //Check for command in args            // Open a new terminal window running the shell            execlp("xterm", "xterm", "-e", "bash", NULL); //Uses execlp for opening new terminal (replacing)            // If execlp returns, it means it failed            perror("Failed to open new terminal");            exit(EXIT_FAILURE);        } else if (strcmp(args[0], "gcc") == 0 && strcmp(args[1] + strlen(args[1]) - 2, ".c") == 0) {            // Compile the .c file and execute it            char *executable_name = strdup(args[1]);            executable_name[strlen(executable_name) - 2] = '\0'; // Remove .c extension            char *compiled_args[] = {"./a.out", NULL};            int compile_status = execvp("gcc", args); // Compile the .c file            if (compile_status == -1) {                fprintf(stderr, "%s does not exist\t\n", args[1]);                exit(EXIT_FAILURE);            }            execvp("./a.out", compiled_args); // Execute the compiled file            // If execvp returns, it means it failed            perror("Compilation and execution failed");            exit(EXIT_FAILURE);        } else {            // Execute the command            execvp(args[0], args);            // If execvp returns, it means it failed            exit(EXIT_FAILURE);        }    } else { //After forking child process        // Parent process        if (!background) {            // Wait for the foreground process to complete            do {                waitpid(pid, &status, WUNTRACED);                 //WUNTRACED used for returning function is child is stopped (Not terminated)            } while (!WIFEXITED(status) && !WIFSIGNALED(status));        } else {            // Store background process information            background_processes[num_background_processes].pid = pid;            strcpy(background_processes[num_background_processes].command, args[0]);            num_background_processes++;            printf("[%d] %d\n", num_background_processes, pid);        }        // Print the PID of the new shell if "newt" command was entered        if (strcmp(args[0], "newt") == 0) {            printf("New copy of shell bash created with PID: %d\n", pid);        }    }}void bring_to_foreground() {    // Bring the last background process to the foreground    if (num_background_processes > 0) { //Checks for Bg processes        int status;        pid_t last_background_pid = background_processes[num_background_processes - 1].pid;        // Get the current terminal attributes        struct termios tattr;        tcgetattr(STDIN_FILENO, &tattr);        // Set the process group of the background process as the foreground process group        tcsetpgrp(STDIN_FILENO, getpgid(last_background_pid));        // Send SIGCONT signal to resume the background process        kill(last_background_pid, SIGCONT);        // Wait for the background process to complete or suspend        waitpid(last_background_pid, &status, WUNTRACED);        // Restore the terminal attributes        tcsetattr(STDIN_FILENO, TCSANOW, &tattr);        // Reset the process group of the shell as the foreground process group        tcsetpgrp(STDIN_FILENO, getpgrp());        // If the process is terminated, remove it from background processes        if (WIFSIGNALED(status) || WIFEXITED(status)) {            printf("[%d] %d finished\n", num_background_processes, last_background_pid);            num_background_processes--;        }    } else {        fprintf(stderr, "No background process to bring to foreground.\n");    }}void concatenate_files(char **files) {    FILE *file;    int c;    //Function iterates over each file array    for (int i = 0; files[i] != NULL; i++) { //Loop continues till it finds null pointer        file = fopen(files[i], "r"); //For each file it tries to open with fopen command        if (file == NULL) { //If fopen returns null            fprintf(stderr, "Error: File %s does not exist.\n", files[i]); //Print error            return;        }        printf("Concatenation of %s:\n", files[i]); //If file opening is successful        while ((c = fgetc(file)) != EOF) { //Iterates till End of File            putchar(c);        }        fclose(file);    }}void handle_signal(int signum) { //signum parameter    if (shell_pgid == tcgetpgrp(STDIN_FILENO)) {        // Shell is in the foreground, so terminate the shell        printf("Ctrl+C pressed. Exiting shell.\n");        exit(EXIT_SUCCESS); //If the process is in fg    } else {        // If Shell is in the background, just print a message        printf("Ctrl+C pressed. Ignored.\n");    }}void execute_piped_commands(char **commands) { //Array of strings as input command    int pipefd[2];    int fd_in = 0;    char *command;    while ((command = *commands++) != NULL) {        pipe(pipefd); //new pipe is created using pipe system call        pid_t pid = fork(); //child process is forked using fork sustem call        if (pid < 0) {            perror("Fork failed");            exit(EXIT_FAILURE);        } else if (pid == 0) {            // Child process            dup2(fd_in, 0); // Set the input to the previous command's output            if (*commands != NULL) {                dup2(pipefd[1], 1); // Set the output to the next command's input            }            close(pipefd[0]); // Close read end of the pipe            // Execute the command            char *args[MAX_ARGUMENTS];            int argc = 0;            //The command is tokenized into individual arguments using strok            char *token = strtok(command, " \n");             while (token != NULL) {                args[argc++] = token;                token = strtok(NULL, " \n");            }            args[argc] = NULL;            execvp(args[0], args); // Execute the command            // If execvp returns, it means it failed            perror("Execution failed");            exit(EXIT_FAILURE);        } else {            // Parent process            wait(NULL);            close(pipefd[1]); // Close write end of the pipe            fd_in = pipefd[0]; // Set input for the next command        }    }}void executing_with_condition(char *input) {    int status; // Used to capture the exit status of child processes    bool previousSuccess = true; // Track the execution status of the last command    char *commands[MAX_COMMANDS];    char *operators[MAX_COMMANDS - 1] = {NULL}; // Array to hold the operators between commands    char *command; // To hold the individual command extracted from input    char *rest = input; // Pointer to remaining commands    int num_commands = 0; // Count of total commands    // Tokenize input string based on && and ||    while ((command = strtok_r(rest, "&&||", &rest)) && num_commands < MAX_COMMANDS) {        commands[num_commands] = command;        // Check the next character in rest to determine the operator used        if (rest != NULL && *rest == '&') {            operators[num_commands] = "&&";        } else if (rest != NULL && *rest == '|') {            operators[num_commands] = "||";        }        num_commands++;        // Move past the operator for the next iteration        if (rest != NULL && (*rest == '&' || *rest == '|')) rest++;    } //Loop continues till all commands are extracted or MAX COMMAND limit is reached    // Execute each command based on the logical conditions    for (int i = 0; i < num_commands; i++) {        if (i == 0 || // Always execute the first command            (previousSuccess && operators[i-1] && strcmp(operators[i-1], "&&") == 0) || // Execute if the previous command succeeded with &&            (!previousSuccess && operators[i-1] && strcmp(operators[i-1], "||") == 0)) { // Execute if the previous command failed with ||            // Split the command into arguments            char *args[MAX_ARGS + 1];            int argc = 0;            char *arg = strtok(commands[i], " ");            while (arg != NULL && argc < MAX_ARGS) {                args[argc++] = arg;                arg = strtok(NULL, " ");            }            args[argc] = NULL; // Null-terminate the list of arguments            // Fork and execute the command            pid_t pid = fork();            if (pid < 0) {                perror("Fork failed");                exit(1);            } else if (pid == 0) { // Child process                execvp(args[0], args);                perror("Exec failed");                exit(1); // Exit with an error status if execvp fails            } else { // Parent process                wait(&status); // Wait for the child process to finish                previousSuccess = WIFEXITED(status) && WEXITSTATUS(status) == 0;            }        }        // No need to update previousSuccess if we're not executing the command    }}int main() {    shell_pgid = getpid(); // Get the process group ID of the shell    // Set signal handler for SIGINT (Ctrl+C)    signal(SIGINT, handle_signal);    char input[MAX_COMMAND_LENGTH];    char *commands[MAX_COMMAND_LENGTH]; // Array to store individual commands    char *args[MAX_ARGUMENTS];    char *files[MAX_FILES]; // Array to store file names for concatenation    int background;    while (1) {        // Read user input        printf("shell24$ ");        fgets(input, sizeof(input), stdin); //Read the user input and store in input variable        input[strcspn(input, "\n")] = '\0'; //For removing newline character                //Check if user input has logical operators        if (strstr(input, "&&") != NULL || strstr(input, "||") != NULL) {            //If it has, it will trigger conditional_command and calls conditional execution            conditional_command = 1;            // Execute logic for conditional execution command            executing_with_condition(input);                    }                ///Check if user input has "|", if exists, call "execute_pipes_commands"        else if (strstr(input, "|") != NULL) { printf ("Inside pipe function\n");            // Parse the input into commands separated by "|"            char *commands[MAX_COMMAND_LENGTH];            int num_commands = 0;            char *command = strtok(input, "|");            while (command != NULL) {                commands[num_commands++] = strdup(command);                command = strtok(NULL, "|");            }            commands[num_commands] = NULL;            // Execute piped commands            execute_piped_commands(commands);            // Free allocated memory for commands            for (int i = 0; i < num_commands; i++) {                free(commands[i]);            }        }        // Parse the input into commands separated by ";"        int num_commands = 0;        char *command = strtok(input, ";\n");        while (command != NULL) {            commands[num_commands++] = strdup(command);            command = strtok(NULL, ";\n");        }        // Execute each command sequentially        for (int i = 0; i < num_commands; i++) {            command = commands[i];            // Parse each command into arguments            background = 0;            int argc = 0;            int file_index = 0; // Index for files array            char *token = strtok(command, " \n");            while (token != NULL && conditional_command != 1) {                if (strcmp(token, "&") == 0) {  printf ("Inside bg\n");                    background = 1;                } else if (strcmp(token, "fg") == 0) {                    bring_to_foreground();                    break;                } else if (strcmp(token, "#") == 0) {                    // Concatenate files                    if (argc > 0) {                        files[file_index] = NULL; // Terminate files array                        concatenate_files(files);                        file_index = 0; // Reset file index                    } else {                        fprintf(stderr, "Error: Invalid usage of # symbol.\n");                    }                } else {                    if (argc >= MAX_ARGUMENTS - 1) {                        fprintf(stderr, "Error: Too many arguments for the command.\n");                        break;                    }                    args[argc++] = strdup(token);                    if (strcmp(token, "#") != 0) {                        files[file_index++] = strdup(token); // Store file name for concatenation                    }                }                token = strtok(NULL, " \n");            }            args[argc] = NULL;            // Execute the command            if (argc > 0 && strcmp(args[0], "#") != 0) {                execute_command(args, background);            }            // Free allocated memory for arguments and files            for (int i = 0; i < argc; i++) {                free(args[i]);            }            for (int i = 0; i < file_index; i++) {                free(files[i]);            }        }        // Free allocated memory for commands        for (int i = 0; i < num_commands; i++) {            free(commands[i]);        }    }    return 0;}